* Passive-source Seismic-processing (PsSp)
  :PROPERTIES:
  :CUSTOM_ID: passive-source-seismic-processing-pssp
  :END:
PsSp aims to provide an OS-independent, graphical, seismic-processing software
package targeted at passive-source seismologists.

** Screenshots
   :PROPERTIES:
   :CUSTOM_ID: screenshots
   :END:
*** MacOS 13.4 - 16 June 2023 (Scaled)
    :PROPERTIES:
    :CUSTOM_ID: macos-13.4---16-june-2023-scaled
    :END:
#+caption: PsSp Main Window on MacOS 13.4, scaled resolution
[[file:screenshots/MacOS/pssp_main_window_16June2023.png]]

*** MacOS 13.4 - 24 June 2023 (Unscaled)
    :PROPERTIES:
    :CUSTOM_ID: macos-13.4---24-june-2023-unscaled
    :END:
#+caption: PsSp Main Window on MacOS 13.4, unscaled resolution
[[file:screenshots/MacOS/pssp_main_windows_24June2023_MacOS_Retina_unscaled.png]]

*** Ubuntu Linux 23.04 - 29 June 2023
    :PROPERTIES:
    :CUSTOM_ID: ubuntu-linux-23.04---29-june-2023
    :END:
#+caption: PsSp Main Window on Ubuntu 23.04
[[file:screenshots/Linux/pssp_29June2023_FilterResponse_Ubuntu2304.png]]

*** Windows 11 - 22 June 2023
    :PROPERTIES:
    :CUSTOM_ID: windows-11---22-june-2023
    :END:
#+caption: PsSp Main Window on Windows 11
[[file:screenshots/Windows/pssp_main_window_22June2023_Windows11.png]]

** Why does this exist?
   :PROPERTIES:
   :CUSTOM_ID: why-does-this-exist
   :END:
*** Summary
    :PROPERTIES:
    :CUSTOM_ID: summary
    :END:
The purpose of this project is to *extend the productivity suite of the
passive-source seismologist*. There exist great tools for writing manuscripts
(e.g. MS Word, LibreOffice, LaTeX, ...). There exist great tools for creating
presentations (e.g. MS Powerpoint, Impress Presentation, ...). There exist great
tools for communicating with each other across the world (Outlook, Thunderbird,
Zoom, MS Teams, ...). What tools exist for doing seismic analysis? Far too
often, it is whatever the analyst manages to cludge together, provided it
/seems/ to do the job.

*** Introduction
    :PROPERTIES:
    :CUSTOM_ID: introduction
    :END:
Despite the various seismological tools that exist, and because of how they are
designed, the seismologist will *most likely* need to code their own tool(s) (as
a shell script stitching programs together, as a Python script using ObsPy, as a
SAC macro, etc.). While the ability to do that if it is desired by the
researcher is awesome, the need to do it is unfortunate as not everyone wants to
(or knows how to) write their own codes. It gets worse when you consider the
performance of these codes, or how the codes end up becoming obsolete after a
short time (try using someone's old Python scripts, or Matlab codes, have them
not work and be stuck trying to figure out what is wrong instead of making
progress on your research).

*** Discussion
    :PROPERTIES:
    :CUSTOM_ID: discussion
    :END:
The primary issues that I see today are:

1) There is a lack of available tools with a modern graphical user interface
   (GUI).
2) Often tools only do one or a few jobs. This makes life easier for the
   developer (following the [[https://en.wikipedia.org/wiki/KISS_principle][KISS philosophy]]), but it makes life harder for the
   end-user. Often the end-user needs to stitch/cludge together different tools,
   developed by different persons/groups, in order to perform a given research
   task.
3) The additional complication of OS-exclusive software, locking users of the
   wrong operating system out from certain tools is really quite unfortunate.
4) The tools are often not parallel at all.

The problem is magnified when you consider that often the end-user doesn't
necessarily know how to use the tool, nor the underlying assumptions, nor the
limitations. Often, these tools were never designed to be shared and therefore
are designed in a non-intuitive fashion, with virtually no comments in the
actual code. These tools are often not documented (or under-documented, or even
/incorrectly documented/), they tend to be assumed as just plain /obvious/,
despite that being entirely dependent upon a very specific (and undocumented)
workflow by someone who simply does not care about UI/UX.

The disconnected nature of the typical seismic workflow leads to reproducibility
issues. A researcher must keep track of every step taken in the analysis
manually, without error. This is easy when a research task is a straight line.
However, when there is back-tracking, iterative analysis with minor tweaks,
abandoned lines of exploration, and so on, it becomes exceedingly difficult to
be able to provide an accurate account of the actual processing steps necessary
to consistently reproduce presented/published results. In this age of modern
computing, it is simply *absurd* that the seismologist has no other choice than
to work with this /severe tool-deficit/.

The researcher shouldn't need to expend immense amounts of
time/energy/mental-bandwidth on making their tools, nor on making them work
together. They should be focused on doing science. While advances in machine
learning are allowing the modern seismologist to parse massive amounts of data
with relatively little effort, we must still look at our data and question the
validity of our analysis/interpretation. And we should be able to do this with
relative ease and minimal pain.

*** Purpose
    :PROPERTIES:
    :CUSTOM_ID: purpose
    :END:
PsSp is being developed to solve these problems; to empower the seismologist
with tools that are easy to use and foster exploration. By enabling the
scientist to do exploratory analysis quickly, easily, iteratively, and visually
I hope to allow the end-user to improve their intuitive understanding of what
they are doing with their data so that they can make an informed descision of
how best to proceed with their analysis. I hope this will also make entry into
seismology easier (undergrads, summer interns, new graduate students, etc.) and
will make it easier for more-seasoned seismologists to use newer and more
advanced tools, thus improving everyone's workflow and the quality of research
that is accomplished while minimizing the amount of time (and frustration)
devoted to simply trying to get a functional workflow.

** Current status
   :PROPERTIES:
   :CUSTOM_ID: current-status
   :END:
This is extremely early in development.

*** Current Focus: Migrate to [[https://doc.qt.io/qt-5.15/][Qt5]]
    :PROPERTIES:
    :CUSTOM_ID: current-focus-migrate-to-qt5
    :END:
It has been a while! I'm going to be getting back into the swing of developing
this project more regularly (dedicate at least a few hours a week).

That being said, it is time for a new focus: to date, this project has used Dear
ImGui to provide the graphical user interface; that is okay, but doesn't play
well with musl (see below) and isn't really necessary for this sort of project
(immediate mode graphics is better for other types of applications). Qt5 is
stable, popular, cross platform, and ideally will not be very resource
intensive. Plus, it'll provide a more natural look for the program that I think
will be greatly appreciated. I think it is better to do this now, than to wait
until the program is more complex as this will have a large effect on how the
program itself is designed.

I will be continuing to add more testing to improve code coverage, though will
pass on using Valgrind at present as premature optimization is the root of all
evil.

*** Last Focus: Unit and Integration Testing for Improved Stability
    :PROPERTIES:
    :CUSTOM_ID: last-focus-unit-and-integration-testing-for-improved-stability
    :END:
This project has gone too far without proper testing. Bugs are hard to find,
they disrupt the mental flow when working on a given problem via distraction
with a new, different, and annoying problem. Testing will help mitigate these
issues. As the code-base grows, this will become progressively more important
and more difficult to freshly introduce to the workflow. To that end I am
extending the freeze on new analysis functionality. If this is going to be used
it cannot cause the analyst headaches due to being unstable.

To that end, the focus will be on implementing [[https://en.wikipedia.org/wiki/Unit_testing][unit testing]] and [[https://en.wikipedia.org/wiki/Integration_testing][integration
testing]]. I will be using [[https://github.com/catchorg/Catch2][Catch2]] to setup and execute the tests. Once that is
all said and done, another round of bug squashing will need to occur. After
that, there will finally be a sufficiently stable base to justify building upon.
I'm also looking into using [[https://valgrind.org/][Valgrind]] to incorporate some more advanced dynamic
analysis tools into the development workflow.

** ToDo
   :PROPERTIES:
   :CUSTOM_ID: todo
   :END:
See the Todo list at the top of the [[file:ToDo.md]] file for more info on what is
currently going-on/planned for the future as well as the above discussion on the
project focus.

** Dependencies
   :PROPERTIES:
   :CUSTOM_ID: dependencies
   :END:
Dependencies that are marked as 'Git submodule' are handled automatically. Other
packages must be installed via your package manager of choice or manually. For
those other packages I provide installation guidance for MacOS, Linux, and
Windows systems [[#compilation-instructions][here]].

*** Necessary
    :PROPERTIES:
    :CUSTOM_ID: necessary
    :END:
- [[https://www.boost.org/][Boost]]
  - Provides some convenient string manipulation operations.
- [[https://github.com/ocornut/imgui/tree/v1.89.5][Dear ImGui]] v1.89.6
  - This provides the OS-independent GUI.
  - Git submodule.
- [[https://www.fftw.org/][FFTW3]]
  - This is necessary for spectral functionality (FFT, IFFT).
  - By using a plan-pool, that has an appropriate semaphore lock, I have
    implemented fft and ifft in a thread-safe fashion (super-fast!).
- [[https://www.glfw.org/][GLFW3]]
  - This is a graphical backend for the GUI.
- [[https://github.com/aiekick/ImGuiFileDialog][ImGuiFileDialog]],
  master branch
  - This adds OS-independent File Dialogs to Dear ImGui.
  - Git submodule.
- [[https://github.com/epezent/implot][ImPlot]]
  - This adds OS-independent plotting functionality to Dear ImGui.
  - Git submodule.
- [[https://msgpack.org/][MessagePack]]
  - Provides data-serialization, used to serialize/deserialize program settings
    from a binary file.
- [[https://github.com/arbCoding/sac-format][sac-format]]
  - This provides binary SAC-file (seismic) I/O, both low-level functions and
    the high-level SacStream class.
  - Git submodule.
- [[https://sqlite.org/][SQLite3]]
  - Projects are implemented as internal sqlite3 databases.
  - We are able to maintain data provenance information, processing checkpoints,
    and so on via a serverless relational database.

*** Optional
    :PROPERTIES:
    :CUSTOM_ID: optional
    :END:
- [[https://github.com/catchorg/Catch2][Catch2]] v3.3.2
  - This provides the unit/integration testing framework
  - Git submodule.
- [[https://github.com/Reputeless/Xoshiro-cpp][Xoshiro-cpp]]
  - This provides good and fast pseudo-random number generation
  - Currently only used to generate random data for unit tests
  - Will be implemented in PsSp for use eventually (to generate random noise,
    generate random perturbations in an inversion, etc.)
  - Git submodule.

** Compilation instructions
   :PROPERTIES:
   :CUSTOM_ID: compilation-instructions
   :END:
I test this on M1 MacOS (Ventura 13.4.1), x86_64 Linux (Ubuntu 23.04), and
x86_64 Windows (Windows 11, using MSYS2/Mingw).

*** [[file:screenshots/pssp_main_window_16June2023.png][MacOS]]
    :PROPERTIES:
    :CUSTOM_ID: macos
    :END:
Using [[https://brew.sh/][Homebrew]]

#+begin_example
brew install fftw glfw msgpack-cxx sqlite boost
#+end_example

*NOTE* For MacOS users, if you want a stand-alone =Application= (=PsSp.app=, no
need to execute from the terminal) there are additional requirements. Please see
the [[#special-macos-application][additional instructions]] for more information.

*** [[file:screenshots/pssp_main_window_22June2023_Ubuntu2304.png][Linux]]
(Ubuntu 23.04/Debian based)
    :PROPERTIES:
    :CUSTOM_ID: linux-ubuntu-23.04debian-based
    :END:
Using [[https://wiki.debian.org/Apt][apt]]

#+begin_example
sudo apt install libfftw3-dev libglfw3-dev libboost-all-dev libmsgpack-dev libsqlite3-dev
#+end_example

*** [[file:screenshots/pssp_main_window_22June2023_Windows11.png][Windows]]
(Windows 11)
    :PROPERTIES:
    :CUSTOM_ID: windows-windows-11
    :END:
Using [[https://www.msys2.org/][MSYS2]]

#+begin_example
pacman -S mingw-w64-x86_64-toolchain mingw-w64-x86_64-glfw mingw-w64-x86_64-fftw mingw-w64-x86_64-sqlite3 mingw-w64-x86_64-boost mingw-w64-x86_64-msgpack-c
#+end_example

*** Clone and Initialze
    :PROPERTIES:
    :CUSTOM_ID: clone-and-initialze
    :END:
Next you need to clone this project and initialize the
[[file:submodules]]

#+begin_example
git clone https://github.com/arbCoding/PsSp.git
cd PsSp
git submodule update --init
#+end_example

That will download the appropriate submodule dependencies, with the correct
commit version, automatically, from their respective GitHub repositories. You
can confirm that by examining them inside the submodules directory (they will be
empty before you initialize them and populate afterward).

*NOTE* if a submodule is not the correct version (detached head, but submodule
was updated) From the base git dir (PsSp) run

#+begin_example
git submodule update --init --remote submodules/
#+end_example

Then it is a simple as running

#+begin_example
make
#+end_example

The above command will make an executable inside the ./bin/ directory. *Note*
that on Linux/MacOS this will be a file simply named =PsSp= and on Windows it
will instead be =PsSp.exe=.

To run it on Linux/MacOS use

#+begin_example
./bin/PsSp
#+end_example

The above command is used to start PsSp from the command line. On Linux you can
also double click the executable to start it. On MacOS you must first make an
=Application= (instructions to make =PsSp.app= are below).

*MacOS =Application=*

To make =PsSp.app= run

#+begin_example
make macos
#+end_example

=PsSp.app= can be run by double-clicking on the application file.

On Windows you can start it from the command line (MSYS2 knows to switch the =/=
around to a =\= automatically).

#+begin_example
./bin/PsSp.exe
#+end_example

Or by double-clicking on the executable.

*** Cleanup
    :PROPERTIES:
    :CUSTOM_ID: cleanup
    :END:
To cleanup (including removing the compiled programs), run:

#+begin_example
make clean
#+end_example

*** Testing
    :PROPERTIES:
    :CUSTOM_ID: testing
    :END:
To compile and run the tests:

#+begin_example
make tests
#+end_example

*Note* that this will involve compiling [[https://github.com/catchorg/Catch2][Catch2]]. This has been automatically
integrated into the above command. The tests include verification of features as
well as simple benchmarks of various operations performed by PsSp. Testing is
currently part of the main development focus, as discussed in the [[#current-status][current status]]
section.

** Special MacOS =Application=
   :PROPERTIES:
   :CUSTOM_ID: special-macos-application
   :END:
If you want a stand-alone MacOS application file, then there are additional
steps.

I do not take credit for figuring this out, I found this [[https://newbedev.com/building-osx-app-bundle][blog post]] on the topic.

First, I use [[https://github.com/auriamg/macdylibbundler/][dylibbundler]] to handle rebinding the links for the non-standard
dynamically linked libraries. The application bundle requires that they be
included in the application (such that the end-user doesn't need to install
them).

This can be installed via Homebrew

#+begin_example
brew install dylibbundler
#+end_example

You can see which dylib's will need to be modified via the =otool= command after
the program is compiled:

#+begin_example
otool -L ./bin/PsSp
#+end_example

Anything not listed in =/System/Libary/= or =/usr/lib= will need to be included
with the application. Fortunately, *dylibbundler* can handle that for us.

#+begin_example
dylibbundler -s /opt/homebrew/lib/ -od -b -x ./PsSp.app/Contents/MacOS/PsSp -d ./PsSp.app/Contents/libs/
#+end_example

Of course, this is implemented automatically in the [[file:Makefile]], assuming you
also used Homebrew to install the other packages (non-Git submodules).

** Notes on GitHub actions
   :PROPERTIES:
   :CUSTOM_ID: notes-on-github-actions
   :END:
GitHub actions would be great, but at the present moment they are a bit behind.
I cannot use Ubuntu 23.04 (only 22.04, which doesn't have the correct
implementation of the standard library), nor can I use the correct
implementation of the standard library for MacOS (tried). In the future I'll
look back into this, but for now compilation will need to remain local which is
fine.

** MacOS Resolution Issue
   :PROPERTIES:
   :CUSTOM_ID: macos-resolution-issue
   :END:
This is a known issue with Dear ImGui. You can see discussions on the topic by
following these links:

1) [[https://github.com/ocornut/imgui/issues/3757][SDL]]
2) [[https://github.com/ocornut/imgui/issues/5081][GLFW]]
3) [[https://github.com/ocornut/imgui/pull/287][More GLFW]]

Summary: Basically, on MacOS, if you're using a retina display the screen is a
much higher resolution than what is being 'used'. This can be easily checked by
modifying the resolution from the recommended to the maximum. On my M1 MBP the
recommended is 1440x900, which looks great. The maximum is 2560x1600, which is
remarkably small on my 13” screen. Apple knows this, so they scale the UI based
upon the physical size of the screen to determine a best scaled-resolution. Dear
ImGui asks for a window of a given size from the OS, not realizing that the
resolution it receives is a scaled resolution (it assumes a raw resolution). The
end result is that despite having a much higher resolution screen, the screen is
treated as being significantly smaller than it actually is, hence the cluttered
appearance of the UI on the [[file:screenshots/pssp_main_window_16June2023.png][MacOS screenshot]].

In my own testing, the resolution was fixable by modifying the GLFW backend to
scale everything, but the mouse location was incorrect unless the window was in
exclusive fullscreen mode (then it worked fine). That was some progress, but
insufficient to justify making a separate fork of Dear ImGui. Hopefully they fix
the issue in the near future, especially as it seems to be a priority as it
overlaps with their work on multiple viewports (multiple monitors and separate
windows).

*** Fix
    :PROPERTIES:
    :CUSTOM_ID: fix
    :END:
Assuming you want to take full advantage of the High-DPI retina display you
have, you can fix this by simply adjusting the resolution of your computer.
Click the Apple icon in the upper-left of your screen and select =System
Settings=. From there select =Displays=. Select =Show all resolutions= and then
choose the resolution you desire. PsSp will scale accordingly with that, as can
be seen from this [[file:screenshots/pssp_main_windows_24June2023_MacOS_Retina_unscaled.png][screenshot]].

** libc musl support
   :PROPERTIES:
   :CUSTOM_ID: libc-musl-support
   :END:
This project is *not compatible* with [[https://musl.libc.org/][libc musl]]. sac-format seems to work fine
with libc musl, but PsSp does not.

** More information
For more details, checkout the [[file:Makefile]]. It is heavily commented to make it
more accessible.
